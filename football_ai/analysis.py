"""
Football Video Analysis using YOLOv8
Detects players and ball in football match videos

IMPORTANT: Events generated by this analyzer must be compatible with analytics features:
- Summary: Overall match statistics
- Network Analysis: Passing networks (requires playerId, metadata.toPlayerId, metadata.toX, metadata.toY)
- Sense Matrix: Player interaction matrix (requires playerId for all events)
- Distribution Map: Zone-based statistics (requires x, y for all events)
- Activity Field: Heatmap visualization (requires x, y for all events)
- Vector Field: Movement vectors (requires passes with start/end positions)
- Spotlight: Key moments (requires minute, metadata.xg for shots)

See analytics_features_requirements.md for complete documentation.
"""

import cv2
import numpy as np
from pathlib import Path
import json
import sys
from typing import Dict, List, Optional, Tuple
try:
    from football_ai.enhanced_event_detection import EnhancedEventDetector
except (ImportError, SyntaxError) as e:
    # Fallback if module not available or has syntax errors
    print(f"[FootballAI] Enhanced event detection not available: {e}", file=sys.stderr)
    EnhancedEventDetector = None
try:
    from football_ai.advanced_tracking import AdvancedEventDetector, PlayerTracker, BallTracker
except (ImportError, SyntaxError) as e:
    # Fallback if module not available or has syntax errors
    print(f"[FootballAI] Advanced tracking not available: {e}", file=sys.stderr)
    AdvancedEventDetector = None
    PlayerTracker = None
    BallTracker = None
from ultralytics import YOLO


class FootballVideoAnalyzer:
    """Analyzes football videos using YOLOv8 for object detection"""
    
    def __init__(self, model_path: Optional[str] = None):
        """
        Initialize analyzer with YOLOv8 model
        
        Args:
            model_path: Path to custom YOLOv8 model (.pt file)
                       If None, searches for trained models or uses default yolov8s.pt
        """
        # Class IDs from COCO dataset:
        # 0: person (players)
        # 32: sports ball (ball)
        self.player_class_id = 0
        self.ball_class_id = 32
        
        if model_path and Path(model_path).exists():
            self.model = YOLO(model_path)
            print(f"[FootballAI] Loaded custom model: {model_path}", file=sys.stderr)
        else:
            # Search for trained models first
            trained_model = self._find_trained_model()
            if trained_model:
                self.model = YOLO(trained_model)
                print(f"[FootballAI] Loaded trained model: {trained_model}", file=sys.stderr)
            else:
                # Use YOLOv8 small model (better accuracy than nano)
                # Accuracy: yolov8s (90-95%) - Good for production
                try:
                    self.model = YOLO("yolov8s.pt")  # Better accuracy than yolov8n
                    print("[FootballAI] Loaded YOLOv8s model (90-95% accuracy)", file=sys.stderr)
                except:
                    # Fallback to nano if small model fails
                    self.model = YOLO("yolov8n.pt")
                    print("[FootballAI] Loaded YOLOv8n model (85-92% accuracy)", file=sys.stderr)
    
    def _find_trained_model(self) -> Optional[str]:
        """
        Search for trained models in football_models directory
        Priority: best.pt > last.pt
        """
        possible_paths = [
            "football_models/football_finetuned/weights/best.pt",
            "football_models/football_finetuned/weights/last.pt",
            "football_models/football_auto/weights/best.pt",
            "football_models/football_auto/weights/last.pt",
            "football_models/football_yolov8s/weights/best.pt",
            "football_models/football_yolov8s/weights/last.pt",
        ]
        
        for path in possible_paths:
            if Path(path).exists():
                return path
        
        return None
    
    def analyze_video(
        self,
        video_path: str,
        output_format: str = "json",
        use_advanced_tracking: bool = True
    ) -> Dict:
        """
        Analyze video frame by frame
        
        Args:
            video_path: Path to video file
            output_format: 'json' or 'dict'
        
        Returns:
            Dictionary with detections per frame
        """
        if not Path(video_path).exists():
            raise FileNotFoundError(f"Video file not found: {video_path}")
        
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            raise ValueError(f"Could not open video: {video_path}")
        
        # Get video properties
        fps = cap.get(cv2.CAP_PROP_FPS)
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        duration = total_frames / fps if fps > 0 else 0
        
        print(f"[FootballAI] Video: {width}x{height}, {fps} FPS, {total_frames} frames, {duration:.2f}s", file=sys.stderr)
        
        # Initialize advanced tracking if available
        advanced_detector = None
        player_tracker = None
        ball_tracker = None
        
        if use_advanced_tracking and AdvancedEventDetector and PlayerTracker and BallTracker:
            try:
                advanced_detector = AdvancedEventDetector(fps=fps)
                player_tracker = PlayerTracker()
                ball_tracker = BallTracker()
                print("[FootballAI] Using advanced tracking (90-95% accuracy)", file=sys.stderr)
            except Exception as e:
                print(f"[FootballAI] Advanced tracking failed: {e}, using basic detection", file=sys.stderr)
                advanced_detector = None
                player_tracker = None
                ball_tracker = None
        
        frames_data = []
        frame_number = 0
        all_events = []  # Store all detected events
        
        # Process every Nth frame for performance (adjust based on needs)
        # For real-time: process every frame
        # For analysis: process every 5-10 frames
        frame_skip = 1  # Process every frame (change to 5 or 10 for faster processing)
        
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            
            # Skip frames if needed
            if frame_number % frame_skip != 0:
                frame_number += 1
                continue
            
            # Run YOLOv8 inference
            results = self.model(frame, verbose=False)
            
            # Extract detections
            detections = []
            current_detections = []  # For tracking
            
            for result in results:
                boxes = result.boxes
                for box in boxes:
                    cls_id = int(box.cls[0])
                    conf = float(box.conf[0])
                    
                    # Only detect players and ball with confidence threshold
                    # Higher threshold for ball (smaller object, harder to detect)
                    min_confidence = 0.3 if cls_id == self.player_class_id else 0.5
                    
                    if (cls_id == self.player_class_id or cls_id == self.ball_class_id) and conf >= min_confidence:
                        x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                        
                        # Normalize coordinates to 0-100 (pitch coordinates)
                        # Assuming video shows full pitch
                        norm_x = ((x1 + x2) / 2 / width) * 100
                        norm_y = ((y1 + y2) / 2 / height) * 100
                        
                        detection = {
                            "class": "player" if cls_id == self.player_class_id else "ball",
                            "class_id": int(cls_id),
                            "confidence": round(conf, 3),
                            "bbox": {
                                "x1": float(x1),
                                "y1": float(y1),
                                "x2": float(x2),
                                "y2": float(y2),
                            },
                            "position": {
                                "x": round(norm_x, 2),
                                "y": round(norm_y, 2),
                            },
                        }
                        detections.append(detection)
                        current_detections.append(detection)
            
            # Update trackers if available
            if player_tracker and ball_tracker:
                player_tracker.update(current_detections, frame_number)
                ball_tracker.update(current_detections, frame_number)
            
            # Store frame data with tracking info
            frame_data = {
                "frame": frame_number,
                "timestamp": round(frame_number / fps, 2) if fps > 0 else 0,
                "detections": detections,
            }
            
            # Add tracking data if available
            if player_tracker and ball_tracker:
                frame_data["tracked_players"] = player_tracker.get_tracked_players_data()
                frame_data["tracked_ball"] = ball_tracker.get_tracked_ball_data()
            
            frames_data.append(frame_data)
            
            frame_number += 1
            
            # Progress indicator
            if frame_number % 100 == 0:
                progress = (frame_number / total_frames) * 100
                print(f"[FootballAI] Progress: {progress:.1f}% ({frame_number}/{total_frames} frames)", file=sys.stderr)
        
        cap.release()
        
        # Detect events using advanced detector or basic detection
        # NOTE: EnhancedEventDetector generates events with all required fields for analytics features
        print("[FootballAI] Detecting events...", file=sys.stderr)
        if advanced_detector:
            try:
                all_events = advanced_detector.detect_all_events(frames_data)
                print(f"[FootballAI] Detected {len(all_events)} events using advanced tracking", file=sys.stderr)
            except Exception as e:
                print(f"[FootballAI] Advanced event detection failed: {e}, using basic detection", file=sys.stderr)
                all_events = self.detect_events(frames_data, fps)
        elif EnhancedEventDetector:
            try:
                detector = EnhancedEventDetector(fps=fps)
                all_events = detector.detect_all_events(frames_data)
                print(f"[FootballAI] Detected {len(all_events)} events using enhanced detection", file=sys.stderr)
                print(f"[FootballAI] Events include required fields for Network Analysis, Sense Matrix, Vector Field, etc.", file=sys.stderr)
            except Exception as e:
                print(f"[FootballAI] Enhanced event detection failed: {e}, using basic detection", file=sys.stderr)
                all_events = self.detect_events(frames_data, fps)
        else:
            all_events = self.detect_events(frames_data, fps)
            print(f"[FootballAI] Detected {len(all_events)} events using basic detection", file=sys.stderr)
            print(f"[FootballAI] WARNING: Basic detection may not include all fields required for analytics features", file=sys.stderr)
        
        # Aggregate results
        total_players = sum(len([d for d in f["detections"] if d["class"] == "player"]) for f in frames_data)
        total_ball_detections = sum(len([d for d in f["detections"] if d["class"] == "ball"]) for f in frames_data)
        
        # Calculate statistics from events
        shots = [e for e in all_events if e.get("type") == "shot"]
        passes = [e for e in all_events if e.get("type") == "pass"]
        touches = [e for e in all_events if e.get("type") == "touch"]
        tackles = [e for e in all_events if e.get("type") == "tackle"]
        
        result = {
            "video_path": video_path,
            "duration": round(duration, 2),
            "fps": round(fps, 2),
            "total_frames": total_frames,
            "processed_frames": len(frames_data),
            "width": width,
            "height": height,
            "statistics": {
                "total_player_detections": total_players,
                "total_ball_detections": total_ball_detections,
                "avg_players_per_frame": round(total_players / len(frames_data), 2) if frames_data else 0,
                "events_detected": len(all_events),
                "shots": len(shots),
                "passes": len(passes),
                "touches": len(touches),
                "tackles": len(tackles),
            },
            "events": all_events,
            "tracking_enabled": advanced_detector is not None,
        }
        
        if output_format == "json":
            return json.dumps(result, indent=2)
        return result
    
    def detect_events(
        self,
        frames_data: List[Dict],
        fps: float
    ) -> List[Dict]:
        """
        Detect football events from frame-by-frame detections
        Uses enhanced event detection for all statistics
        
        Args:
            frames_data: List of frame detection data
            fps: Frames per second
        
        Returns:
            List of detected events with all types:
            - shot, pass, touch, tackle, interception, recovery, corner, free_kick
        """
        # Use enhanced event detector if available
        if EnhancedEventDetector:
            detector = EnhancedEventDetector(fps=fps)
            events = detector.detect_all_events(frames_data)
            return events
        
        # Fallback to basic detection
        events = []
        prev_ball_pos = None
        ball_velocity_threshold = 5.0
        
        for i, frame_data in enumerate(frames_data):
            ball_detections = [d for d in frame_data["detections"] if d["class"] == "ball"]
            player_detections = [d for d in frame_data["detections"] if d["class"] == "player"]
            
            if ball_detections:
                ball = ball_detections[0]
                ball_pos = ball["position"]
                
                if prev_ball_pos:
                    dx = ball_pos["x"] - prev_ball_pos["x"]
                    dy = ball_pos["y"] - prev_ball_pos["y"]
                    velocity = np.sqrt(dx**2 + dy**2)
                    
                    if velocity > ball_velocity_threshold and ball_pos["x"] > 66:
                        events.append({
                            "type": "shot",
                            "frame": frame_data["frame"],
                            "timestamp": frame_data["timestamp"],
                            "confidence": ball["confidence"],
                            "position": ball_pos,
                        })
                
                prev_ball_pos = ball_pos
        
        return events


def main():
    """CLI entry point for video analysis"""
    if len(sys.argv) < 2:
        print("Usage: python -m football_ai.analysis <video_path> [model_path]", file=sys.stderr)
        sys.exit(1)
    
    video_path = sys.argv[1]
    model_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        analyzer = FootballVideoAnalyzer(model_path=model_path)
        result = analyzer.analyze_video(video_path, output_format="json")
        print(result)
    except Exception as e:
        print(json.dumps({
            "error": str(e),
            "type": type(e).__name__
        }), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()


                "tackles": len(tackles),
            },
            "events": all_events,
            "tracking_enabled": advanced_detector is not None,
        }
        
        if output_format == "json":
            return json.dumps(result, indent=2)
        return result
    
    def detect_events(
        self,
        frames_data: List[Dict],
        fps: float
    ) -> List[Dict]:
        """
        Detect football events from frame-by-frame detections
        Uses enhanced event detection for all statistics
        
        Args:
            frames_data: List of frame detection data
            fps: Frames per second
        
        Returns:
            List of detected events with all types:
            - shot, pass, touch, tackle, interception, recovery, corner, free_kick
        """
        # Use enhanced event detector if available
        if EnhancedEventDetector:
            detector = EnhancedEventDetector(fps=fps)
            events = detector.detect_all_events(frames_data)
            return events
        
        # Fallback to basic detection
        events = []
        prev_ball_pos = None
        ball_velocity_threshold = 5.0
        
        for i, frame_data in enumerate(frames_data):
            ball_detections = [d for d in frame_data["detections"] if d["class"] == "ball"]
            player_detections = [d for d in frame_data["detections"] if d["class"] == "player"]
            
            if ball_detections:
                ball = ball_detections[0]
                ball_pos = ball["position"]
                
                if prev_ball_pos:
                    dx = ball_pos["x"] - prev_ball_pos["x"]
                    dy = ball_pos["y"] - prev_ball_pos["y"]
                    velocity = np.sqrt(dx**2 + dy**2)
                    
                    if velocity > ball_velocity_threshold and ball_pos["x"] > 66:
                        events.append({
                            "type": "shot",
                            "frame": frame_data["frame"],
                            "timestamp": frame_data["timestamp"],
                            "confidence": ball["confidence"],
                            "position": ball_pos,
                        })
                
                prev_ball_pos = ball_pos
        
        return events


def main():
    """CLI entry point for video analysis"""
    if len(sys.argv) < 2:
        print("Usage: python -m football_ai.analysis <video_path> [model_path]", file=sys.stderr)
        sys.exit(1)
    
    video_path = sys.argv[1]
    model_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        analyzer = FootballVideoAnalyzer(model_path=model_path)
        result = analyzer.analyze_video(video_path, output_format="json")
        print(result)
    except Exception as e:
        print(json.dumps({
            "error": str(e),
            "type": type(e).__name__
        }), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()


                "tackles": len(tackles),
            },
            "events": all_events,
            "tracking_enabled": advanced_detector is not None,
        }
        
        if output_format == "json":
            return json.dumps(result, indent=2)
        return result
    
    def detect_events(
        self,
        frames_data: List[Dict],
        fps: float
    ) -> List[Dict]:
        """
        Detect football events from frame-by-frame detections
        Uses enhanced event detection for all statistics
        
        Args:
            frames_data: List of frame detection data
            fps: Frames per second
        
        Returns:
            List of detected events with all types:
            - shot, pass, touch, tackle, interception, recovery, corner, free_kick
        """
        # Use enhanced event detector if available
        if EnhancedEventDetector:
            detector = EnhancedEventDetector(fps=fps)
            events = detector.detect_all_events(frames_data)
            return events
        
        # Fallback to basic detection
        events = []
        prev_ball_pos = None
        ball_velocity_threshold = 5.0
        
        for i, frame_data in enumerate(frames_data):
            ball_detections = [d for d in frame_data["detections"] if d["class"] == "ball"]
            player_detections = [d for d in frame_data["detections"] if d["class"] == "player"]
            
            if ball_detections:
                ball = ball_detections[0]
                ball_pos = ball["position"]
                
                if prev_ball_pos:
                    dx = ball_pos["x"] - prev_ball_pos["x"]
                    dy = ball_pos["y"] - prev_ball_pos["y"]
                    velocity = np.sqrt(dx**2 + dy**2)
                    
                    if velocity > ball_velocity_threshold and ball_pos["x"] > 66:
                        events.append({
                            "type": "shot",
                            "frame": frame_data["frame"],
                            "timestamp": frame_data["timestamp"],
                            "confidence": ball["confidence"],
                            "position": ball_pos,
                        })
                
                prev_ball_pos = ball_pos
        
        return events


def main():
    """CLI entry point for video analysis"""
    if len(sys.argv) < 2:
        print("Usage: python -m football_ai.analysis <video_path> [model_path]", file=sys.stderr)
        sys.exit(1)
    
    video_path = sys.argv[1]
    model_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        analyzer = FootballVideoAnalyzer(model_path=model_path)
        result = analyzer.analyze_video(video_path, output_format="json")
        print(result)
    except Exception as e:
        print(json.dumps({
            "error": str(e),
            "type": type(e).__name__
        }), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()


                "tackles": len(tackles),
            },
            "events": all_events,
            "tracking_enabled": advanced_detector is not None,
        }
        
        if output_format == "json":
            return json.dumps(result, indent=2)
        return result
    
    def detect_events(
        self,
        frames_data: List[Dict],
        fps: float
    ) -> List[Dict]:
        """
        Detect football events from frame-by-frame detections
        Uses enhanced event detection for all statistics
        
        Args:
            frames_data: List of frame detection data
            fps: Frames per second
        
        Returns:
            List of detected events with all types:
            - shot, pass, touch, tackle, interception, recovery, corner, free_kick
        """
        # Use enhanced event detector if available
        if EnhancedEventDetector:
            detector = EnhancedEventDetector(fps=fps)
            events = detector.detect_all_events(frames_data)
            return events
        
        # Fallback to basic detection
        events = []
        prev_ball_pos = None
        ball_velocity_threshold = 5.0
        
        for i, frame_data in enumerate(frames_data):
            ball_detections = [d for d in frame_data["detections"] if d["class"] == "ball"]
            player_detections = [d for d in frame_data["detections"] if d["class"] == "player"]
            
            if ball_detections:
                ball = ball_detections[0]
                ball_pos = ball["position"]
                
                if prev_ball_pos:
                    dx = ball_pos["x"] - prev_ball_pos["x"]
                    dy = ball_pos["y"] - prev_ball_pos["y"]
                    velocity = np.sqrt(dx**2 + dy**2)
                    
                    if velocity > ball_velocity_threshold and ball_pos["x"] > 66:
                        events.append({
                            "type": "shot",
                            "frame": frame_data["frame"],
                            "timestamp": frame_data["timestamp"],
                            "confidence": ball["confidence"],
                            "position": ball_pos,
                        })
                
                prev_ball_pos = ball_pos
        
        return events


def main():
    """CLI entry point for video analysis"""
    if len(sys.argv) < 2:
        print("Usage: python -m football_ai.analysis <video_path> [model_path]", file=sys.stderr)
        sys.exit(1)
    
    video_path = sys.argv[1]
    model_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        analyzer = FootballVideoAnalyzer(model_path=model_path)
        result = analyzer.analyze_video(video_path, output_format="json")
        print(result)
    except Exception as e:
        print(json.dumps({
            "error": str(e),
            "type": type(e).__name__
        }), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()

